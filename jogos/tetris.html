<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Tetris Remastered</title>
  <style>
    body {
      margin: 0;
      background: #050510;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      touch-action: none;
    }

    #game-container {
      position: relative;
      display: flex;
      gap: 20px;
      align-items: flex-start;
      transform-origin: center top;
    }

    canvas {
      background: #000;
      box-shadow: 0 0 40px rgba(0, 243, 255, 0.15);
      border: 2px solid #333;
      border-radius: 4px;
    }

    .panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: 100px;
    }

    .box {
      background: rgba(20, 20, 30, 0.8);
      border: 1px solid #444;
      padding: 10px;
      text-align: center;
      border-radius: 8px;
    }

    .label {
      font-size: 12px;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }

    .value {
      font-size: 20px;
      font-weight: bold;
      color: #00f3ff;
      text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
    }

    /* Canvas menores para Next/Hold */
    #nextCanvas, #holdCanvas {
      background: #000;
      width: 80px;
      height: 80px;
      margin: 0 auto;
    }

    /* Overlay de Start/Game Over */
    #overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      backdrop-filter: blur(5px);
    }

    h1 {
      font-size: 48px;
      margin: 0 0 10px;
      background: linear-gradient(to bottom, #fff, #00f3ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    button {
      background: transparent;
      color: #00f3ff;
      border: 2px solid #00f3ff;
      padding: 15px 40px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      text-transform: uppercase;
      transition: 0.2s;
      box-shadow: 0 0 15px rgba(0, 243, 255, 0.3);
      margin-top: 20px;
    }
    button:hover {
      background: #00f3ff;
      color: #000;
      box-shadow: 0 0 30px rgba(0, 243, 255, 0.6);
    }

    /* Controles Mobile */
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      height: 160px;
      z-index: 50;
      pointer-events: none; /* Deixa passar clique onde não tem botão */
    }
    
    .d-pad, .action-btn {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 24px;
      user-select: none;
    }
    
    .d-pad:active, .action-btn:active { background: rgba(0, 243, 255, 0.4); border-color: #00f3ff; }

    /* Layout Botões */
    #btn-left { width: 60px; height: 60px; bottom: 50px; left: 20px; }
    #btn-right { width: 60px; height: 60px; bottom: 50px; left: 100px; }
    #btn-down { width: 60px; height: 60px; bottom: 10px; left: 60px; }
    #btn-drop { width: 70px; height: 70px; bottom: 50px; right: 20px; border-color: #ff00ff; color: #ff00ff; }
    #btn-rotate { width: 60px; height: 60px; bottom: 30px; right: 110px; }
    #btn-hold { width: 50px; height: 50px; top: -140px; left: 20px; border-radius: 8px; font-size: 14px;}

  </style>
</head>
<body>

  <div id="game-container">
    
    <!-- Painel Esquerdo (Hold) -->
    <div class="panel">
      <div class="box">
        <div class="label">Hold</div>
        <canvas id="holdCanvas" width="80" height="80"></canvas>
      </div>
      <div class="box">
        <div class="label">Score</div>
        <div class="value" id="score">0</div>
      </div>
      <div class="box">
        <div class="label">Level</div>
        <div class="value" id="level">1</div>
      </div>
    </div>

    <!-- Área Principal -->
    <div style="position:relative">
      <canvas id="board" width="300" height="600"></canvas>
      
      <div id="overlay">
        <h1>Neon Tetris</h1>
        <p style="color:#aaa; margin-bottom:10px">Setas / WASD / Toque</p>
        <button id="btn-start">Iniciar</button>
      </div>
    </div>

    <!-- Painel Direito (Next) -->
    <div class="panel">
      <div class="box">
        <div class="label">Next</div>
        <canvas id="nextCanvas" width="80" height="80"></canvas>
      </div>
      <div class="box">
        <div class="label">Lines</div>
        <div class="value" id="lines">0</div>
      </div>
    </div>

  </div>

  <!-- Controles Mobile -->
  <div id="mobile-controls">
    <div id="btn-left" class="d-pad">◀</div>
    <div id="btn-right" class="d-pad">▶</div>
    <div id="btn-down" class="d-pad">▼</div>
    <div id="btn-rotate" class="action-btn">↻</div>
    <div id="btn-drop" class="action-btn">⤓</div>
    <div id="btn-hold" class="action-btn" style="position:absolute;">H</div>
  </div>

<script>
(function() {
  /**
   * NEON TETRIS REMASTERED
   */
  
  // Elementos
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('nextCanvas');
  const nextCtx = nextCanvas.getContext('2d');
  const holdCanvas = document.getElementById('holdCanvas');
  const holdCtx = holdCanvas.getContext('2d');
  
  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');
  const overlay = document.getElementById('overlay');
  const btnStart = document.getElementById('btn-start');

  // Configuração
  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 30;
  const SCALE = window.innerHeight < 700 ? 0.8 : 1; // Ajuste para telas pequenas

  // Aplicar escala
  if(SCALE !== 1) {
    document.getElementById('game-container').style.transform = `scale(${SCALE})`;
  }

  // Detectar Mobile
  const isMobile = ('ontouchstart' in window);
  if(isMobile) {
    document.getElementById('mobile-controls').style.display = 'block';
  }

  // Cores Neon (Tetrominoes: I, J, L, O, S, T, Z)
  const COLORS = [
    null,
    '#00f3ff', // I - Cyan
    '#0033ff', // J - Blue
    '#ffaa00', // L - Orange
    '#ffea00', // O - Yellow
    '#00ff00', // S - Green
    '#aa00ff', // T - Purple
    '#ff0055', // Z - Red
  ];

  // Formas das Peças
  const SHAPES = [
    [],
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I
    [[2,0,0],[2,2,2],[0,0,0]],               // J
    [[0,0,3],[3,3,3],[0,0,0]],               // L
    [[4,4],[4,4]],                           // O
    [[0,5,5],[5,5,0],[0,0,0]],               // S
    [[0,6,0],[6,6,6],[0,0,0]],               // T
    [[7,7,0],[0,7,7],[0,0,0]]                // Z
  ];

  // Estado do Jogo
  let board = [];
  let score = 0;
  let lines = 0;
  let level = 1;
  let gameOver = false;
  let isPaused = false;
  
  let piece = null;     // Peça atual
  let nextPiece = null; // Próxima
  let holdPiece = null; // Peça guardada
  let canHold = true;   // Só pode guardar 1x por turno

  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;

  // Efeitos (Partículas)
  let particles = [];

  // Audio Procedural
  const Audio = (function(){
    let ctx;
    function init(){ if(!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)(); }
    function play(freq, type='square', len=0.1, vol=0.1) {
      if(!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, ctx.currentTime);
      gain.gain.setValueAtTime(vol, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + len);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + len);
    }
    return { init, play };
  })();

  // --- Lógica Principal ---

  function createPiece(type) {
    if(!type) type = (Math.random() * 7 | 0) + 1;
    return {
      matrix: SHAPES[type],
      pos: {x: Math.floor(COLS/2) - Math.ceil(SHAPES[type][0].length/2), y: 0},
      type: type
    };
  }

  function resetGame() {
    Audio.init();
    board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    score = 0;
    lines = 0;
    level = 1;
    dropInterval = 1000;
    holdPiece = null;
    canHold = true;
    gameOver = false;
    isPaused = false;
    particles = [];
    
    updateScore();
    piece = createPiece();
    nextPiece = createPiece();
    
    overlay.style.display = 'none';
    lastTime = 0;
    dropCounter = 0;
    
    draw();
    requestAnimationFrame(update);
  }

  function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if (dir > 0) matrix.forEach(row => row.reverse());
    else matrix.reverse();
  }

  function playerRotate(dir) {
    const pos = piece.pos.x;
    let offset = 1;
    rotate(piece.matrix, dir);
    // Wall Kick simples
    while (collide(board, piece)) {
      piece.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > piece.matrix[0].length) {
        rotate(piece.matrix, -dir);
        piece.pos.x = pos;
        return;
      }
    }
    Audio.play(200, 'triangle', 0.05);
  }

  function playerDrop() {
    piece.pos.y++;
    if (collide(board, piece)) {
      piece.pos.y--;
      merge(board, piece);
      Audio.play(100, 'sawtooth', 0.1);
      playerReset();
      arenaSweep();
      updateScore();
    }
    dropCounter = 0;
  }
  
  function playerHardDrop() {
    while (!collide(board, piece)) {
      piece.pos.y++;
    }
    piece.pos.y--;
    merge(board, piece);
    Audio.play(150, 'sawtooth', 0.15);
    
    // Efeito visual de impacto
    createExplosion(piece.pos.x * BLOCK_SIZE + (piece.matrix[0].length*BLOCK_SIZE)/2, piece.pos.y * BLOCK_SIZE + piece.matrix.length*BLOCK_SIZE, '#fff');

    playerReset();
    arenaSweep();
    updateScore();
    dropCounter = 0;
  }

  function playerReset() {
    piece = nextPiece;
    nextPiece = createPiece();
    piece.pos.y = 0;
    piece.pos.x = Math.floor(COLS/2) - Math.ceil(piece.matrix[0].length/2);
    canHold = true;

    if (collide(board, piece)) {
      gameOver = true;
      overlay.style.display = 'flex';
      overlay.querySelector('h1').innerText = "GAME OVER";
      overlay.querySelector('button').innerText = "Tentar Novamente";
      Audio.play(100, 'sawtooth', 0.5);
    }
  }
  
  function playerHold() {
    if(!canHold) return;
    
    if(holdPiece === null) {
      holdPiece = createPiece(piece.type);
      piece = nextPiece;
      nextPiece = createPiece();
    } else {
      const temp = createPiece(piece.type);
      piece = createPiece(holdPiece.type);
      holdPiece = temp;
    }
    
    // Reset posição
    piece.pos.y = 0;
    piece.pos.x = Math.floor(COLS/2) - Math.ceil(piece.matrix[0].length/2);
    
    canHold = false;
    Audio.play(300, 'sine', 0.1);
  }

  function arenaSweep() {
    let rowCount = 0;
    outer: for (let y = board.length - 1; y > 0; --y) {
      for (let x = 0; x < board[y].length; ++x) {
        if (board[y][x] === 0) {
          continue outer;
        }
      }
      
      const row = board.splice(y, 1)[0].fill(0);
      board.unshift(row);
      ++y;
      
      // Efeito de linha limpa
      createExplosion(canvas.width/2, y * BLOCK_SIZE, '#00f3ff', 50);
      rowCount++;
    }
    
    if (rowCount > 0) {
      // Pontuação Clássica Nintendo
      const lineScores = [0, 40, 100, 300, 1200];
      score += lineScores[rowCount] * level;
      lines += rowCount;
      level = Math.floor(lines / 10) + 1;
      
      // Aumentar velocidade
      dropInterval = Math.max(100, 1000 - (level * 50));
      
      Audio.play(400 + (rowCount*100), 'square', 0.3);
    }
  }
  
  function updateScore() {
    scoreEl.innerText = score;
    linesEl.innerText = lines;
    levelEl.innerText = level;
  }
  
  // --- Renderização ---

  function drawMatrix(matrix, offset, context, ghost = false) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          const px = (x + offset.x) * BLOCK_SIZE;
          const py = (y + offset.y) * BLOCK_SIZE;
          
          context.fillStyle = COLORS[value];
          
          if(ghost) {
            context.globalAlpha = 0.2;
            context.strokeStyle = COLORS[value];
            context.lineWidth = 1;
            context.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
            context.globalAlpha = 1.0;
          } else {
            // Efeito Neon (Borda brilhante)
            context.shadowBlur = 15;
            context.shadowColor = COLORS[value];
            context.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
            
            // Miolo mais claro
            context.fillStyle = 'rgba(255,255,255,0.3)';
            context.fillRect(px + 4, py + 4, BLOCK_SIZE - 8, BLOCK_SIZE - 8);
            
            context.shadowBlur = 0;
          }
        }
      });
    });
  }
  
  function drawGhost() {
    const ghost = {
      matrix: piece.matrix,
      pos: {x: piece.pos.x, y: piece.pos.y}
    };
    
    while(!collide(board, ghost)) {
      ghost.pos.y++;
    }
    ghost.pos.y--;
    
    drawMatrix(ghost.matrix, ghost.pos, ctx, true);
  }
  
  function drawMiniBoard(currCtx, currPiece) {
    currCtx.fillStyle = '#000';
    currCtx.fillRect(0, 0, 80, 80);
    
    if (currPiece) {
      // Centralizar mini peça
      const offsetX = (80/BLOCK_SIZE - currPiece.matrix[0].length) / 2;
      const offsetY = (80/BLOCK_SIZE - currPiece.matrix.length) / 2;
      
      // Redimensionar contexto temporariamente
      const prevScale = BLOCK_SIZE;
      const miniBlock = 18;
      
      currPiece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            currCtx.fillStyle = COLORS[value];
            currCtx.shadowBlur = 5;
            currCtx.shadowColor = COLORS[value];
            currCtx.fillRect((x + offsetX) * 20, (y + offsetY) * 20, 18, 18);
            currCtx.shadowBlur = 0;
          }
        });
      });
    }
  }
  
  function createExplosion(x, y, color, count=15) {
    for(let i=0; i<count; i++) {
      particles.push({
        x: x, y: y,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        life: 1.0,
        color: color
      });
    }
  }

  function draw() {
    // Limpar
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid sutil
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1;
    for(let i=0; i<COLS; i++) {
      ctx.beginPath(); ctx.moveTo(i*BLOCK_SIZE, 0); ctx.lineTo(i*BLOCK_SIZE, canvas.height); ctx.stroke();
    }
    for(let i=0; i<ROWS; i++) {
      ctx.beginPath(); ctx.moveTo(0, i*BLOCK_SIZE); ctx.lineTo(canvas.width, i*BLOCK_SIZE); ctx.stroke();
    }

    if(piece) {
        drawGhost();
        drawMatrix(board, {x: 0, y: 0}, ctx);
        drawMatrix(piece.matrix, piece.pos, ctx);
    }
    
    drawMiniBoard(nextCtx, nextPiece);
    drawMiniBoard(holdCtx, holdPiece);
    
    // Partículas
    for(let i=particles.length-1; i>=0; i--) {
      let p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.03;
      
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, 4, 4);
      
      if(p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1.0;
  }

  function update(time = 0) {
    if(gameOver) return;

    const deltaTime = time - lastTime;
    lastTime = time;
    
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
      playerDrop();
    }
    
    draw();
    requestAnimationFrame(update);
  }

  // --- Input ---
  
  function handleInput(key) {
    if(gameOver) return;
    
    if (key === 'ArrowLeft' || key === 'a') {
      piece.pos.x--;
      if (collide(board, piece)) piece.pos.x++;
      else Audio.play(100, 'triangle', 0.05);
    } else if (key === 'ArrowRight' || key === 'd') {
      piece.pos.x++;
      if (collide(board, piece)) piece.pos.x--;
      else Audio.play(100, 'triangle', 0.05);
    } else if (key === 'ArrowDown' || key === 's') {
      playerDrop();
    } else if (key === 'ArrowUp' || key === 'w') {
      playerRotate(1);
    } else if (key === ' ' || key === 'h') { // Espaço agora é Hard Drop
      playerHardDrop();
    } else if (key === 'c' || key === 'Shift') {
      playerHold();
    }
  }

  document.addEventListener('keydown', event => {
    handleInput(event.key);
  });

  // Mobile Input Bindings
  const btnLeft = document.getElementById('btn-left');
  const btnRight = document.getElementById('btn-right');
  const btnDown = document.getElementById('btn-down');
  const btnRotate = document.getElementById('btn-rotate');
  const btnDrop = document.getElementById('btn-drop');
  const btnHold = document.getElementById('btn-hold');
  
  // Touch repeat helper
  function addTouchRepeat(btn, action) {
    let timer;
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      action();
      timer = setInterval(action, 150);
    });
    btn.addEventListener('touchend', () => clearInterval(timer));
  }
  
  addTouchRepeat(btnLeft, () => handleInput('ArrowLeft'));
  addTouchRepeat(btnRight, () => handleInput('ArrowRight'));
  addTouchRepeat(btnDown, () => handleInput('ArrowDown'));
  
  btnRotate.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('ArrowUp'); });
  btnDrop.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(' '); });
  btnHold.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput('c'); });

  // Iniciar
  btnStart.addEventListener('click', resetGame);
  
})();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pac-Man Neon Ultra</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      touch-action: none;
    }

    #game-container {
      position: relative;
      box-shadow: 0 0 50px rgba(255, 215, 0, 0.15);
      border: 2px solid #333;
      border-radius: 4px;
      background: #05050a;
    }

    canvas {
      display: block;
    }

    #ui-layer {
      position: absolute;
      top: 0; left: 0; width: 100%;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
      font-weight: bold;
      font-size: 20px;
      text-shadow: 0 0 10px #ffd700;
      z-index: 10;
    }

    #overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      backdrop-filter: blur(5px);
    }

    h1 {
      font-size: 48px;
      color: #ffd700;
      text-transform: uppercase;
      margin: 0 0 10px;
      text-shadow: 0 0 20px #ffd700;
    }

    button {
      background: transparent;
      color: #ffd700;
      border: 2px solid #ffd700;
      padding: 15px 40px;
      font-size: 20px;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: bold;
      transition: 0.2s;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
      margin-top: 20px;
    }
    button:hover {
      background: #ffd700;
      color: #000;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
    }

    /* Mobile D-Pad */
    #mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 150px;
      height: 150px;
      z-index: 50;
    }
    .d-btn {
      position: absolute;
      width: 50px; height: 50px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      display: flex; justify-content: center; align-items: center;
      font-size: 24px; user-select: none; color: #fff;
    }
    .d-btn:active { background: rgba(255, 215, 0, 0.3); border-color: #ffd700; }
    #btn-up { top: 0; left: 50px; }
    #btn-down { bottom: 0; left: 50px; }
    #btn-left { top: 50px; left: 0; }
    #btn-right { top: 50px; right: 0; }

  </style>
</head>
<body>

  <div id="game-container">
    <div id="ui-layer">
      <div>SCORE: <span id="scoreVal">0</span></div>
      <div>HIGH: <span id="highVal">0</span></div>
    </div>

    <div id="overlay">
      <h1>Pac-Man</h1>
      <p style="color:#aaa; margin-bottom:10px">Setas / WASD para mover</p>
      <button id="btn-start">Jogar</button>
    </div>

    <canvas id="gameCanvas"></canvas>
  </div>

  <div id="mobile-controls">
    <div id="btn-up" class="d-btn">▲</div>
    <div id="btn-left" class="d-btn">◀</div>
    <div id="btn-right" class="d-btn">▶</div>
    <div id="btn-down" class="d-btn">▼</div>
  </div>

<script>
(function() {
  /**
   * PAC-MAN NEON REMASTERED (Engine refeita do zero)
   * Grid-based movement, Collision detection, Ghost AI, Power Pellets.
   */

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  
  // Configurações do Grid
  const TILE_SIZE = 20;
  const ROWS = 21;
  const COLS = 19;
  
  canvas.width = COLS * TILE_SIZE;
  canvas.height = ROWS * TILE_SIZE;

  // Ajuste de escala para telas
  function resize() {
    const scale = Math.min(window.innerWidth / canvas.width, window.innerHeight / canvas.height) * 0.9;
    document.getElementById('game-container').style.transform = `scale(${scale})`;
  }
  window.addEventListener('resize', resize);
  resize();

  // Detectar Mobile
  if('ontouchstart' in window) {
    document.getElementById('mobile-controls').style.display = 'block';
  }

  // Mapa (1 = Parede, 0 = Dot, 2 = Vazio, 3 = Power Pellet, 4 = Porta Fantasma)
  // Layout clássico simplificado para caber no grid
  const mapDesign = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,3,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,3,1],
    [1,0,1,1,1,0,1,1,0,1,0,1,1,0,1,1,1,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1],
    [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
    [1,1,1,1,0,1,1,1,2,1,2,1,1,1,0,1,1,1,1],
    [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
    [1,1,1,1,0,1,2,1,1,4,1,1,2,1,0,1,1,1,1],
    [2,2,2,2,0,2,2,1,2,2,2,1,2,2,0,2,2,2,2], // Túnel
    [1,1,1,1,0,1,2,1,1,1,1,1,2,1,0,1,1,1,1],
    [2,2,2,1,0,1,2,2,2,2,2,2,2,1,0,1,2,2,2],
    [1,1,1,1,0,1,0,1,1,1,1,1,0,1,0,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,1,1,0,1,0,1,1,1,0,1,1,0,1],
    [1,3,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,3,1],
    [1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,0,1,1],
    [1,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2] // Rodapé vazio
  ];

  // Estado do Jogo
  let walls = [];
  let dots = [];
  let powerPellets = [];
  let score = 0;
  let highScore = localStorage.getItem('pacman_high') || 0;
  let gameRunning = false;
  let animationId;
  let powerModeTime = 0;
  let wakaTimer = 0;

  // Áudio Procedural
  const Audio = (function(){
    let ctx;
    function init(){ if(!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)(); }
    
    function playTone(freq, type, dur, vol=0.1) {
      if(!ctx) return;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, ctx.currentTime);
      g.gain.setValueAtTime(vol, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
      o.connect(g); g.connect(ctx.destination);
      o.start(); o.stop(ctx.currentTime + dur);
    }

    function waka() {
      if(!ctx) return;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(100, now);
      osc.frequency.linearRampToValueAtTime(300, now + 0.1);
      osc.frequency.linearRampToValueAtTime(100, now + 0.2);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.2);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(); osc.stop(now + 0.2);
    }
    
    return { init, playTone, waka };
  })();

  // Classes
  class Entity {
    constructor(x, y, color) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.dir = {x:0, y:0};
      this.nextDir = {x:0, y:0};
      this.speed = 0.08; // Tiles por frame (aprox)
      this.tileX = x;
      this.tileY = y;
      this.progress = 0; // 0 a 1 entre tiles
    }

    draw() {
      const px = (this.tileX + this.progress * this.dir.x) * TILE_SIZE + TILE_SIZE/2;
      const py = (this.tileY + this.progress * this.dir.y) * TILE_SIZE + TILE_SIZE/2;
      
      ctx.fillStyle = this.color;
      ctx.shadowBlur = 10;
      ctx.shadowColor = this.color;
      ctx.beginPath();
      ctx.arc(px, py, TILE_SIZE/2 - 2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    move() {
      // Avança progresso
      if(this.dir.x !== 0 || this.dir.y !== 0) {
        this.progress += this.speed;
      }

      // Chegou no centro do tile?
      if(this.progress >= 1) {
        this.tileX += this.dir.x;
        this.tileY += this.dir.y;
        this.progress = 0;
        
        // Warp Tunnel
        if(this.tileX < 0) this.tileX = COLS - 1;
        else if(this.tileX >= COLS) this.tileX = 0;

        this.onCenterTile();
      }
    }

    canMove(dx, dy) {
      const tx = this.tileX + dx;
      const ty = this.tileY + dy;
      
      // Tunnel check
      if(tx < 0 || tx >= COLS) return true;
      if(ty < 0 || ty >= ROWS) return false;

      // Colisão Parede
      if(mapDesign[ty][tx] === 1) return false;
      // Colisão Porta Fantasma (Só fantasma pode passar em teoria, mas simplificamos: player não)
      if(mapDesign[ty][tx] === 4 && this instanceof Pacman) return false;
      
      return true;
    }

    onCenterTile() {
      // Override
    }
  }

  class Pacman extends Entity {
    constructor() {
      super(9, 15, '#ffd700');
      this.speed = 0.15;
      this.mouthOpen = 0;
      this.mouthSpeed = 0.2;
    }

    draw() {
      const px = (this.tileX + this.progress * this.dir.x) * TILE_SIZE + TILE_SIZE/2;
      const py = (this.tileY + this.progress * this.dir.y) * TILE_SIZE + TILE_SIZE/2;
      
      // Animação Boca
      this.mouthOpen += this.mouthSpeed;
      if(this.mouthOpen > 0.25 || this.mouthOpen < 0) this.mouthSpeed *= -1;
      const angle = Math.atan2(this.dir.y, this.dir.x);

      ctx.fillStyle = this.color;
      ctx.shadowBlur = 15;
      ctx.shadowColor = this.color;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.arc(px, py, TILE_SIZE/2 - 1, angle + Math.max(0, this.mouthOpen * Math.PI), angle + Math.PI*2 - Math.max(0, this.mouthOpen * Math.PI));
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    onCenterTile() {
      // Tenta mudar para nextDir
      if(this.nextDir.x !== 0 || this.nextDir.y !== 0) {
        if(this.canMove(this.nextDir.x, this.nextDir.y)) {
          this.dir = this.nextDir;
          this.nextDir = {x:0, y:0};
        }
      }

      // Se não pode continuar na dir atual, para
      if(!this.canMove(this.dir.x, this.dir.y)) {
        this.dir = {x:0, y:0};
      }
      
      // Comer Dots
      const dotIndex = dots.findIndex(d => d.x === this.tileX && d.y === this.tileY);
      if(dotIndex !== -1) {
        dots.splice(dotIndex, 1);
        score += 10;
        Audio.playTone(600, 'sine', 0.05, 0.05);
      }

      // Comer Power Pellets
      const powerIndex = powerPellets.findIndex(p => p.x === this.tileX && p.y === this.tileY);
      if(powerIndex !== -1) {
        powerPellets.splice(powerIndex, 1);
        score += 50;
        powerModeTime = 600; // frames
        Audio.playTone(800, 'square', 0.2);
      }
      
      // Som Waka Waka
      if((this.dir.x !== 0 || this.dir.y !== 0) && wakaTimer++ > 15) {
        Audio.waka();
        wakaTimer = 0;
      }
      
      // Vitória?
      if(dots.length === 0 && powerPellets.length === 0) {
        initLevel();
      }
    }
  }

  class Ghost extends Entity {
    constructor(x, y, color, type) {
      super(x, y, color);
      this.baseColor = color;
      this.type = type; // 0=Blinky, 1=Pinky, 2=Inky, 3=Clyde
      this.speed = 0.08 + (Math.random() * 0.02); // Variação leve
      this.scared = false;
      this.dead = false;
    }

    draw() {
      const px = (this.tileX + this.progress * this.dir.x) * TILE_SIZE + TILE_SIZE/2;
      const py = (this.tileY + this.progress * this.dir.y) * TILE_SIZE + TILE_SIZE/2;
      
      let drawColor = this.dead ? '#333' : (this.scared ? '#00f' : this.baseColor);
      if(this.scared && powerModeTime < 120 && Math.floor(Date.now()/200)%2===0) drawColor = '#fff'; // Piscar

      ctx.fillStyle = drawColor;
      ctx.shadowBlur = 10;
      ctx.shadowColor = drawColor;
      
      // Corpo (Domo + Retângulo)
      ctx.beginPath();
      ctx.arc(px, py - 2, TILE_SIZE/2 - 2, Math.PI, 0);
      ctx.lineTo(px + TILE_SIZE/2 - 2, py + TILE_SIZE/2 - 2);
      ctx.lineTo(px - TILE_SIZE/2 + 2, py + TILE_SIZE/2 - 2);
      ctx.fill();
      
      // Olhos
      if(!this.scared || this.dead) {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(px - 3, py - 4, 2, 0, Math.PI*2);
        ctx.arc(px + 3, py - 4, 2, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }

    onCenterTile() {
      // IA Simples: Escolher direção válida que minimiza distância ao alvo
      
      const dirs = [
        {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}
      ];
      
      // Não pode voltar 180 graus (exceto se scared/dead)
      const opposite = {x: -this.dir.x, y: -this.dir.y};
      
      let validMoves = dirs.filter(d => {
        if(!this.dead && !this.scared && d.x === opposite.x && d.y === opposite.y) return false;
        return this.canMove(d.x, d.y);
      });
      
      if(validMoves.length === 0) validMoves = [opposite]; // Beco sem saída

      let target = {x: pacman.tileX, y: pacman.tileY};
      
      if(this.dead) {
        target = {x: 9, y: 9}; // Casa dos fantasmas
        if(this.tileX === 9 && this.tileY === 9) {
            this.dead = false;
            this.scared = false;
        }
      } else if(this.scared) {
        // Alvo aleatório (correr)
        target = {x: Math.random()*COLS, y: Math.random()*ROWS};
      } else {
         // Comportamentos diferentes
         if(this.type === 1) target.x += 4; // Pinky ambushes
         if(this.type === 2) target.y += 4; // Inky
         if(this.type === 3 && Math.random() < 0.5) target = {x:0, y:0}; // Clyde wanders
      }

      // Escolher melhor movimento
      let bestDir = validMoves[0];
      let minDist = 99999;
      
      validMoves.forEach(d => {
        const tx = this.tileX + d.x;
        const ty = this.tileY + d.y;
        const dist = Math.hypot(tx - target.x, ty - target.y);
        
        // Se scared, maximiza distância, senão minimiza
        if(this.scared && !this.dead) {
            if(dist > minDist) { minDist = dist; bestDir = d; } // Erro lógico proposital para aleatoriedade
            else if (Math.random() < 0.3) bestDir = d;
        } else {
            if(dist < minDist) { minDist = dist; bestDir = d; }
        }
      });
      
      this.dir = bestDir;
    }
  }

  // Instâncias
  let pacman;
  let ghosts = [];

  function initLevel() {
    walls = [];
    dots = [];
    powerPellets = [];
    
    // Parse Map
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const type = mapDesign[r][c];
        if(type === 1) walls.push({x:c, y:r});
        if(type === 0) dots.push({x:c, y:r});
        if(type === 3) powerPellets.push({x:c, y:r});
      }
    }

    pacman = new Pacman();
    ghosts = [
      new Ghost(9, 9, '#f00', 0), // Blinky
      new Ghost(8, 9, '#ffb8ff', 1), // Pinky
      new Ghost(10, 9, '#00ffff', 2), // Inky
      new Ghost(9, 8, '#ffb852', 3)  // Clyde
    ];
  }

  function gameLoop() {
    if(!gameRunning) return;
    
    ctx.fillStyle = '#05050a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Desenhar Mapa
    // Paredes
    ctx.fillStyle = '#111';
    ctx.strokeStyle = '#00f';
    ctx.lineWidth = 2;
    ctx.shadowBlur = 5;
    ctx.shadowColor = '#00f';
    
    walls.forEach(w => {
      ctx.strokeRect(w.x*TILE_SIZE + 4, w.y*TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);
    });
    ctx.shadowBlur = 0;

    // Dots
    ctx.fillStyle = '#ffb8ae';
    dots.forEach(d => {
      ctx.fillRect(d.x*TILE_SIZE + TILE_SIZE/2 - 2, d.y*TILE_SIZE + TILE_SIZE/2 - 2, 4, 4);
    });

    // Power Pellets
    if(Math.floor(Date.now() / 200) % 2 === 0) {
      ctx.fillStyle = '#fff';
      powerPellets.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x*TILE_SIZE + TILE_SIZE/2, p.y*TILE_SIZE + TILE_SIZE/2, 6, 0, Math.PI*2);
        ctx.fill();
      });
    }

    // Update & Draw Entities
    pacman.move();
    pacman.draw();

    // Power Mode Logic
    if(powerModeTime > 0) {
      powerModeTime--;
      if(powerModeTime === 0) ghosts.forEach(g => g.scared = false);
      else ghosts.forEach(g => g.scared = true);
    }

    ghosts.forEach(g => {
      g.move();
      g.draw();
      
      // Colisão Pacman x Fantasma
      // Distância Euclidiana simples entre pixels
      const dx = (g.tileX * TILE_SIZE) - (pacman.tileX * TILE_SIZE);
      const dy = (g.tileY * TILE_SIZE) - (pacman.tileY * TILE_SIZE);
      const dist = Math.hypot(dx, dy);
      
      if(dist < TILE_SIZE / 1.5) {
        if(g.scared && !g.dead) {
          // Comer Fantasma
          g.dead = true;
          g.scared = false;
          score += 200;
          Audio.playTone(800, 'sawtooth', 0.1);
        } else if(!g.dead) {
          // Game Over
          gameOver();
        }
      }
    });

    // UI Update
    document.getElementById('scoreVal').innerText = score;
    document.getElementById('highVal').innerText = highScore;

    requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    gameRunning = false;
    Audio.playTone(100, 'sawtooth', 0.5);
    if(score > highScore) {
      highScore = score;
      localStorage.setItem('pacman_high', highScore);
    }
    document.getElementById('overlay').style.display = 'flex';
    document.querySelector('#overlay h1').innerText = "GAME OVER";
    document.getElementById('btn-start').innerText = "Tentar Novamente";
  }

  function startGame() {
    Audio.init();
    initLevel();
    score = 0;
    powerModeTime = 0;
    gameRunning = true;
    document.getElementById('overlay').style.display = 'none';
    gameLoop();
  }

  // Inputs
  function handleInput(key) {
    if(key === 'ArrowUp' || key === 'w') pacman.nextDir = {x:0, y:-1};
    if(key === 'ArrowDown' || key === 's') pacman.nextDir = {x:0, y:1};
    if(key === 'ArrowLeft' || key === 'a') pacman.nextDir = {x:-1, y:0};
    if(key === 'ArrowRight' || key === 'd') pacman.nextDir = {x:1, y:0};
  }

  window.addEventListener('keydown', e => handleInput(e.key));
  document.getElementById('btn-start').addEventListener('click', startGame);

  // Mobile
  document.getElementById('btn-up').addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput('ArrowUp'); });
  document.getElementById('btn-down').addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput('ArrowDown'); });
  document.getElementById('btn-left').addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput('ArrowLeft'); });
  document.getElementById('btn-right').addEventListener('touchstart', (e)=>{ e.preventDefault(); handleInput('ArrowRight'); });

})();
</script>
</body>
</html>